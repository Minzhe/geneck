source("lib/BayesianGLasso.R")
expr.data <- read.csv("../data/demo_data.csv")
View(expr.data)
expr.data <- expr.data[1:20, 1:20]
View(expr.data)
p <- ncol(expr.data)
n <- nrow(expr.data)
gene.index <- colnames(expr.data)
expr.mat <- scale(as.matrix(expr.data), center = TRUE, scale = FALSE)
a <- 10^(-2); b <- 10^(-6); iter <- 2000; burn <- 1000
out <- blockGLasso_s(expr.mat, iterations = iter, burnIn = burn, lambdaPriora = a, lambdaPriorb = b, verbose = FALSE)
out <- blockGLasso_s(expr.mat, iterations = iter, burnIn = burn, lambdaPriora = a, lambdaPriorb = b, verbose = TRUE)
est_edge <- which(abs(out) > 0, T)
est_edge <- est_edge[est_edge[, 1] < est_edge[, 2], ]
if (length(est_edge) == 2) est_edge <- matrix(est_edge, 1, 2)
est_edge <- as.data.frame(est_edge)
View(est_edge)
colnames(est_edge) <- c("node1", "node2")
est_edge[,1] <- gene.index[est_edge[,1]]
est_edge[,2] <- gene.index[est_edge[,2]]
View(est_edge)
est_edge <- which(abs(out) > 0, T)
View(out)
prob <- 0.2
est_edge <- which(abs(out) > prob, T)
est_edge <- est_edge[est_edge[, 1] < est_edge[, 2], ]
if (length(est_edge) == 2) est_edge <- matrix(est_edge, 1, 2)
est_edge <- as.data.frame(est_edge)
colnames(est_edge) <- c("node1", "node2")
est_edge[,1] <- gene.index[est_edge[,1]]
est_edge[,2] <- gene.index[est_edge[,2]]
View(est_edge)
p <- ncol(expr.data)
n <- nrow(expr.data)
gene.index <- colnames(expr.data)
expr.mat <- scale(as.matrix(expr.data), center = TRUE, scale = FALSE)
est_edge <- list()
a <- 10^(-2); b <- 10^(-6); iter <- 2000; burn <- 1000
out <- blockGLasso_s(expr.mat, iterations = iter, burnIn = burn, lambdaPriora = a, lambdaPriorb = b, verbose = FALSE)
est_edge[[1]] <- abs(out)
est_res.ns <- matrix(0, p, p)
alpha <- 0.2
for (k in 1:p) {
rsp <- expr.mat[, k]
prd <- t(expr.mat[, -k])
lam <- sqrt(sum(rsp ^ 2)) * qnorm(alpha / (2 * p ^ 2), lower.tail = F)
out <- l2.reg(prd, rsp, lambda = lam)
est_res.ns[k, -k] <- out$estimate
}
suppressMessages(library(corpcor))
suppressMessages(library(CDLasso))
suppressMessages(library(glasso))
source("lib/glasso_SF.R")
source("lib/PCA_CMI.R")
source("lib/CMI2NI.R")
suppressMessages(library(space))
for (k in 1:p) {
rsp <- expr.mat[, k]
prd <- t(expr.mat[, -k])
lam <- sqrt(sum(rsp ^ 2)) * qnorm(alpha / (2 * p ^ 2), lower.tail = F)
out <- l2.reg(prd, rsp, lambda = lam)
est_res.ns[k, -k] <- out$estimate
}
est_edge[[2]] <- (abs(est_res.ns) + t(abs(est_res.ns))) / 2
S <- t(expr.mat) %*% expr.mat / n
out <- glasso(S, rho = 0.6)
est_edge[[3]] <- abs(out$wi)
out <- glasso_sf(expr.mat, alpha = 0.3)
est_edge[[4]] <- abs(out$wi)
out <- pca_cmi(t(expr.mat), 0.03)
est_edge[[5]] <- abs(out$Gval)
out <- space.joint(expr.mat, lam1 = 1 * n, iter = 5)
est_edge[[6]] <- abs(out$ParCor)
for (i in 1:6) {
est_edge[[i]][lower.tri(est_edge[[i]], diag = TRUE)] <- 1
est_edge[[i]][upper.tri(est_edge[[i]], diag = FALSE)] <- rank(-est_edge[[i]][upper.tri(est_edge[[i]], diag = FALSE)])
est_edge[[i]] <- log10(1 / est_edge[[i]])
}
est_edge.ena <- Reduce("+", est_edge)
View(est_edge.ena)
perm.v <- c()
for (i in 1:n.perm) {
est_edge.perm <- perm.edge(edge.list = est_edge)
perm.v <- c(perm.v, est_edge.perm[upper.tri(est_edge.perm, diag = FALSE)])
}
sig.level <- quantile(perm.v, probs = sig.quant)
n.perm <- 10
perm.v <- c()
for (i in 1:n.perm) {
est_edge.perm <- perm.edge(edge.list = est_edge)
perm.v <- c(perm.v, est_edge.perm[upper.tri(est_edge.perm, diag = FALSE)])
}
sig.level <- quantile(perm.v, probs = sig.quant)
perm.edge <- function(edge.list) {
for (i in 1:length(edge.list)) {
edge.list[[i]][upper.tri(edge.list[[i]], diag = FALSE)] <- sample(edge.list[[i]][upper.tri(edge.list[[i]], diag = FALSE)])
}
edge.sum <- Reduce("+", edge.list)
return(edge.sum)
}
perm.v <- c()
for (i in 1:n.perm) {
est_edge.perm <- perm.edge(edge.list = est_edge)
perm.v <- c(perm.v, est_edge.perm[upper.tri(est_edge.perm, diag = FALSE)])
}
sig.level <- quantile(perm.v, probs = sig.quant)
sig.quant <-0.99
sig.level <- quantile(perm.v, probs = sig.quant)
est_edge.sig <- which(est_edge.ena > sig.level & est_edge.ena < 0, TRUE)
View(est_edge.sig)
View(est_edge.perm)
plot(density(perm.v))
sig.level
plot(density(est_edge.ena))
View(est_edge.ena)
est_edge.sig <- which(est_edge.ena > sig.level & est_edge.ena < 0, TRUE)
est_edge.sig <- as.data.frame(est_edge.sig)
colnames(est_edge.sig) <- c("node1", "node2")
est_edge.sig[,1] <- gene.index[est_edge.sig[,1]]
est_edge.sig[,2] <- gene.index[est_edge.sig[,2]]
View(est_edge.sig)
network.ena <- function(expr.data, n.perm, sig.quant, if.bayes) {
if (sig.quant <= 0 | sig.quant >= 1) {
stop('Input error: parameter sig.quant for ena should be between 0 and 1.')
}
p <- ncol(expr.data)
n <- nrow(expr.data)
gene.index <- colnames(expr.data)
expr.mat <- scale(as.matrix(expr.data), center = TRUE, scale = FALSE)
est_edge <- list()
### ns
est_res.ns <- matrix(0, p, p)
alpha <- 0.2
for (k in 1:p) {
rsp <- expr.mat[, k]
prd <- t(expr.mat[, -k])
lam <- sqrt(sum(rsp ^ 2)) * qnorm(alpha / (2 * p ^ 2), lower.tail = F)
out <- l2.reg(prd, rsp, lambda = lam)
est_res.ns[k, -k] <- out$estimate
}
est_edge[[1]] <- (abs(est_res.ns) + t(abs(est_res.ns))) / 2
### glasso
S <- t(expr.mat) %*% expr.mat / n
out <- glasso(S, rho = 0.6)
est_edge[[2]] <- abs(out$wi)
### glasso-sf
out <- glasso_sf(expr.mat, alpha = 0.3)
est_edge[[3]] <- abs(out$wi)
### pcacmi
out <- pca_cmi(t(expr.mat), 0.03)
est_edge[[4]] <- abs(out$Gval)
### space
out <- space.joint(expr.mat, lam1 = 1 * n, iter = 5)
est_edge[[5]] <- abs(out$ParCor)
### BayesianGLasso
if (if.bayes) {
a <- 10^(-2); b <- 10^(-6); iter <- 2000; burn <- 1000
out <- blockGLasso_s(expr.mat, iterations = iter, burnIn = burn, lambdaPriora = a, lambdaPriorb = b, verbose = FALSE)
est_edge[[6]] <- abs(out)
}
### ena
for (i in 1:length(est_edge)) {
est_edge[[i]][lower.tri(est_edge[[i]], diag = TRUE)] <- 1
est_edge[[i]][upper.tri(est_edge[[i]], diag = FALSE)] <- rank(-est_edge[[i]][upper.tri(est_edge[[i]], diag = FALSE)])
est_edge[[i]] <- log10(1 / est_edge[[i]])
}
est_edge.ena <- Reduce("+", est_edge)
### permutate
perm.v <- c()
for (i in 1:n.perm) {
est_edge.perm <- perm.edge(edge.list = est_edge)
perm.v <- c(perm.v, est_edge.perm[upper.tri(est_edge.perm, diag = FALSE)])
}
sig.level <- quantile(perm.v, probs = sig.quant)
### true edge
est_edge.sig <- which(est_edge.ena > sig.level & est_edge.ena < 0, TRUE)
est_edge.sig <- as.data.frame(est_edge.sig)
colnames(est_edge.sig) <- c("node1", "node2")
est_edge.sig[,1] <- gene.index[est_edge.sig[,1]]
est_edge.sig[,2] <- gene.index[est_edge.sig[,2]]
return(est_edge.sig)
}
##############  function  ################
perm.edge <- function(edge.list) {
for (i in 1:length(edge.list)) {
edge.list[[i]][upper.tri(edge.list[[i]], diag = FALSE)] <- sample(edge.list[[i]][upper.tri(edge.list[[i]], diag = FALSE)])
}
edge.sum <- Reduce("+", edge.list)
return(edge.sum)
}
res <- network.ena(expr.data = expr.data, n.perm = 10, sig.quant = 0.99, if.bayes = FALSE)
res
res <- network.ena(expr.data = expr.data, n.perm = 10, sig.quant = 0.95, if.bayes = FALSE)
res
res <- network.ena(expr.data = expr.data, n.perm = 10, sig.quant = 0.9, if.bayes = FALSE)
res
res <- network.ena(expr.data = expr.data, n.perm = 10, sig.quant = 0.95, if.bayes = FALSE)
res
res <- network.ena(expr.data = expr.data, n.perm = 10, sig.quant = 0.95, if.bayes = TRUE)
res
source("bayesiangLasso.R")
source("bayesianglasso.R")
source('~/public_html/geneck/bin/ns.R')
network.ns(expr.data, 0.2)
network.ns(expr.data, 0.1)
network.ns(expr.data, 0.5)
network.ns(expr.data, 0.9)
expr.data <- read.csv("../data/demo_data.csv")
network.ns(expr.data, 0.1)
network.ns(expr.data, 0.2)
network.ns(expr.data, 0.3)
network.ns(expr.data, 0.9)
network.ns(expr.data, 1.0)
network.ns(expr.data, 1.2)
network.ns(expr.data, 0)
network.ns(expr.data, 0.01)
source('~/public_html/geneck/bin/glasso.R')
network.glasso(expr.data, 0)
network.glasso(expr.data, 0.1)
network.glasso(expr.data, 0.5)
network.glasso(expr.data, 0.3)
network.glasso(expr.data, 0.7)
network.glasso(expr.data, 1)
network.glasso(expr.data, 2)
source("lib/PCA_CMI.R")
network.pcacmi <- function(expr.data, lambda) {
if (lambda <= 0) {
stop('Input error: parameter alpha for pcacmi should be larger than 0.')
}
p <- ncol(expr.data)
n <- nrow(expr.data)
gene.index <- colnames(expr.data)
expr.mat <- scale(as.matrix(expr.data), center = TRUE, scale = FALSE)
out <- pca_cmi(t(expr.mat), lambda)
est_edge <- which(out$G == 1, T)
est_edge <- est_edge[est_edge[, 1] < est_edge[, 2], ]
if (length(est_edge) == 2) est_edge <- matrix(est_edge, 1, 2)
est_edge <- as.data.frame(est_edge)
colnames(est_edge) <- c("node1", "node2")
est_edge[,1] <- gene.index[est_edge[,1]]
est_edge[,2] <- gene.index[est_edge[,2]]
return(est_edge)
}
network.pcacmi(expr.data, 0.03)
network.pcacmi(expr.data, 0.1)
network.pcacmi(expr.data, 0.2)
source('~/public_html/geneck/bin/eglasso.R')
network.eglasso(expr.data, hub.index = c(1,2), 0.8, 0.6)
network.eglasso(expr.data, hub.index = c(2, 10), 0.8, 0.6)
network.eglasso(expr.data, hub.index = c(2, 10), 1.2, 0.6)
network.eglasso(expr.data, hub.index = c(2, 10), 1.2, 1.6)
network.eglasso(expr.data, hub.index = c(2, 10), 0.2, 1.6)
network.eglasso(expr.data, hub.index = c(2, 10), 0.5, 3.6)
network.eglasso(expr.data, hub.index = c(2, 10), 0.5, 1.6)
network.eglasso(expr.data, hub.index = c(2, 10), 0.5, 0.6)
network.eglasso(expr.data, hub.index = c(2, 10), 0.1, 0.6)
network.ns(expr.data, 0.3)
network.ns(expr.data, 0.1)
network.ns(expr.data, 0.5)
network.ns(expr.data, 0.7)
network.glasso(expr.data, 0.7)
network.glasso(expr.data, 0.1)
network.glasso(expr.data, 0.3)
network.pcacmi(expr.data, 0.3)
network.pcacmi(expr.data, 0.1)
network.pcacmi(expr.data, 1)
View(network.pcacmi)
source("bayesianglasso.R")
View(network.bayesianglasso)
View(network.bayesianglasso)
source("ena.R")
View(network.ena)
real <- read.csv("~/Downloads/True_edge_real.txt")
View(real)
real <- read.table("~/Downloads/True_edge_real.txt", sep = "\t")
View(real)
real.1 <- real[order(abs(real$V3)),]
View(real.1)
real.1 <- real[order(-abs(real$V3)),]
View(real.1)
i.row <- 20
length(unique(c(real.1$V1[1:i.row], real.1$V2[1:i.row])))
unique(c(real.1$V1[1:i.row], real.1$V2[1:i.row]))
i.row <- 25
unique(c(real.1$V1[1:i.row], real.1$V2[1:i.row]))
i.row <- 20
unique(c(real.1$V1[1:i.row], real.1$V2[1:i.row]))
x <- unique(c(real.1$V1[1:i.row], real.1$V2[1:i.row]))
demo.data <- read.csv("../data/demo_data.csv")
View(demo.data)
sort(x)
demo.data.small <- demo.data[1:80, sort(x)]
View(demo.data.small)
write.csv("../data/demo_data_small.csv", row.names = FALSE)
write.csv(demo.data.small, file = "../data/demo_data_small.csv", row.names = FALSE)
